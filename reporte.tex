

%% This file was auto-generated by IPython.
%% Conversion from the original notebook file:
%%
\documentclass[11pt,english]{article}

%% This is the automatic preamble used by IPython.  Note that it does *not*
%% include a documentclass declaration, that is added at runtime to the overall
%% document.

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}

% Scale down larger images
\usepackage[export]{adjustbox}

%fancy verbatim
\usepackage{fancyvrb}
% needed for markdown enumerations to work
\usepackage{enumerate}

% Slightly bigger margins than the latex defaults
\usepackage{geometry}
\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=2.5cm,rmargin=2.5cm}

% Define a few colors for use in code, links and cell shading
\usepackage{color}
\definecolor{orange}{cmyk}{0,0.4,0.8,0.2}
\definecolor{darkorange}{rgb}{.71,0.21,0.01}
\definecolor{darkgreen}{rgb}{.12,.54,.11}
\definecolor{myteal}{rgb}{.26, .44, .56}
\definecolor{gray}{gray}{0.45}
\definecolor{lightgray}{gray}{.95}
\definecolor{mediumgray}{gray}{.8}
\definecolor{inputbackground}{rgb}{.95, .95, .85}
\definecolor{outputbackground}{rgb}{.95, .95, .95}
\definecolor{traceback}{rgb}{1, .95, .95}

% new ansi colors
\definecolor{brown}{rgb}{0.54,0.27,0.07}
\definecolor{purple}{rgb}{0.5,0.0,0.5}
\definecolor{darkgray}{gray}{0.25}
\definecolor{lightred}{rgb}{1.0,0.39,0.28}
\definecolor{lightgreen}{rgb}{0.48,0.99,0.0}
\definecolor{lightblue}{rgb}{0.53,0.81,0.92}
\definecolor{lightpurple}{rgb}{0.87,0.63,0.87}
\definecolor{lightcyan}{rgb}{0.5,1.0,0.83}

% Framed environments for code cells (inputs, outputs, errors, ...).  The
% various uses of \unskip (or not) at the end were fine-tuned by hand, so don't
% randomly change them unless you're sure of the effect it will have.
\usepackage{framed}

% remove extraneous vertical space in boxes
\setlength\fboxsep{0pt}

% codecell is the whole input+output set of blocks that a Code cell can
% generate.

% TODO: unfortunately, it seems that using a framed codecell environment breaks
% the ability of the frames inside of it to be broken across pages.  This
% causes at least the problem of having lots of empty space at the bottom of
% pages as new frames are moved to the next page, and if a single frame is too
% long to fit on a page, will completely stop latex from compiling the
% document.  So unless we figure out a solution to this, we'll have to instead
% leave the codecell env. as empty.  I'm keeping the original codecell
% definition here (a thin vertical bar) for reference, in case we find a
% solution to the page break issue.

%% \newenvironment{codecell}{%
%%     \def\FrameCommand{\color{mediumgray} \vrule width 1pt \hspace{5pt}}%
%%    \MakeFramed{\vspace{-0.5em}}}
%%  {\unskip\endMakeFramed}

% For now, make this a no-op...
\newenvironment{codecell}{}

 \newenvironment{codeinput}{%
   \def\FrameCommand{\colorbox{inputbackground}}%
   \MakeFramed{\advance\hsize-\width \FrameRestore}}
 {\unskip\endMakeFramed}

\newenvironment{codeoutput}{%
   \def\FrameCommand{\colorbox{outputbackground}}%
   \vspace{-1.4em}
   \MakeFramed{\advance\hsize-\width \FrameRestore}}
 {\unskip\medskip\endMakeFramed}

\newenvironment{traceback}{%
   \def\FrameCommand{\colorbox{traceback}}%
   \MakeFramed{\advance\hsize-\width \FrameRestore}}
 {\endMakeFramed}

% Use and configure listings package for nicely formatted code
\usepackage{listingsutf8}
\lstset{
  language=python,
  inputencoding=utf8x,
  extendedchars=\true,
  aboveskip=\smallskipamount,
  belowskip=\smallskipamount,
  xleftmargin=2mm,
  breaklines=true,
  basicstyle=\small \ttfamily,
  showstringspaces=false,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{myteal},
  stringstyle=\color{darkgreen},
  identifierstyle=\color{darkorange},
  columns=fullflexible,  % tighter character kerning, like verb
}

% The hyperref package gives us a pdf with properly built
% internal navigation ('pdf bookmarks' for the table of contents,
% internal cross-reference links, web links for URLs, etc.)
\usepackage{hyperref}
\hypersetup{
  breaklinks=true,  % so long urls are correctly broken across lines
  colorlinks=true,
  urlcolor=blue,
  linkcolor=darkorange,
  citecolor=darkgreen,
  }

% hardcode size of all verbatim environments to be a bit smaller
\makeatletter 
\g@addto@macro\@verbatim\small\topsep=0.5em\partopsep=0pt
\makeatother 

% Prevent overflowing lines due to urls and other hard-to-break entities.
\sloppy




\begin{document}



\section{Modelado dinámico de la máquina sincrona en el marco de
referencia
dq0}\label{modelado-dinuxe1mico-de-la-muxe1quina-sincrona-en-el-marco-de-referencia-dq0}

\emph{Uriel Sandoval}

Este trabajo reporta los resultados de una simulación dinámica de un
máquina síncrona. Los parametros utilizados son los de un hidro
generador reportado en libro de Krauze.

Se cargan los datos y se crea la instancia:

\begin{codecell}


\begin{codeinput}
\begin{lstlisting}
from sistema_sincrona import Maquina_Sincrona
from datos import cargar_datos
import numpy as np
\end{lstlisting}
\end{codeinput}

\end{codecell}

\begin{codecell}


\begin{codeinput}
\begin{lstlisting}
dat = cargar_datos('krauze_hidro')
maq = Maquina_Sincrona(dat)
\end{lstlisting}
\end{codeinput}

\end{codecell}

Se arranca una simulación con $CI=0$ pero ya girando a velocidad
síncrona para obtener el estado estable:

\begin{codecell}


\begin{codeinput}
\begin{lstlisting}
enlaces = [0]*6
velocidad = [2*np.pi*60]
angulo = [0]
maq.x0 = np.array(enlaces+velocidad+angulo)
maq.dinamico(10)
\end{lstlisting}
\end{codeinput}

\end{codecell}

Se guardan los últimos estados para utilizarlos como las CI del
disturbio:

\begin{codecell}


\begin{codeinput}
\begin{lstlisting}
ci = maq.X[-1][:]
\end{lstlisting}
\end{codeinput}

\end{codecell}

Se crea el evento que se quiere aplicar. En este caso la falla consiste
en aumentar de 0 a par nominal el par mecánico en la flecha del
generador:

\begin{codecell}


\begin{codeinput}
\begin{lstlisting}
falla = {'tipo': 'mod_par',
         'ti': 1,
         'tf': 1,
         'valor': 1}
\end{lstlisting}
\end{codeinput}

\end{codecell}

Se simula nuevamente ya con la falla aplicada al primer segundo:

\begin{codecell}


\begin{codeinput}
\begin{lstlisting}
maq.x0 = ci
maq.eventos.append(falla)
maq.dinamico(5)
\end{lstlisting}
\end{codeinput}
\begin{codeoutput}


\begin{Verbatim}[commandchars=\\\{\}]
(True, {'tf': 1, 'valor': 1, 'tipo': 'mod_par', 'ti': 1})
Se apica evento
(False, {'tf': 1, 'valor': 1, 'tipo': 'mod_par', 'ti': 1})
Se libera evento
\end{Verbatim}

\end{codeoutput}

\end{codecell}

\subsection{Resultados}\label{resultados}

\begin{codecell}


\begin{codeinput}
\begin{lstlisting}
%pylab inline
\end{lstlisting}
\end{codeinput}
\begin{codeoutput}


\begin{Verbatim}[commandchars=\\\{\}]
Populating the interactive namespace from numpy and matplotlib
\end{Verbatim}

\end{codeoutput}

\end{codecell}

\subsubsection{Voltajes}\label{voltajes}

\begin{codecell}


\begin{codeinput}
\begin{lstlisting}
estilos = ['k-', 'k:', 'k-.', 'k--']
for p, nombre in enumerate(maq.nombres['V']):
    plot(maq.t, maq.data['V'][:, p], estilos[p],linewidth=1, label='$'+nombre+'$')
legend(loc=0)
xlabel('T $(s)$')
ylabel('V (pu)')
\end{lstlisting}
\end{codeinput}
\begin{codeoutput}




\begin{verbatim}
<matplotlib.text.Text at 0x10a7e2190>
\end{verbatim}



\begin{center}
\includegraphics[max size={0.7\textwidth}{0.9\textheight}]{reporte_files/reporte_15_1.png}
\par
\end{center}

\end{codeoutput}

\end{codecell}

Esta gráfica de los voltajes muestra como hay un caida en el voltaje de
eje directa que está relacionado con el voltaje en terminales ABC de la
máquina. Eso se podría compensar al agregar un AVR que regulara la
excitación.

\subsubsection{Velocidad ángulo}\label{velocidad-uxe1ngulo}

\begin{codecell}


\begin{codeinput}
\begin{lstlisting}
_, ax1 = subplots()
ax2 = ax1.twinx()
ax1.plot(maq.t, maq.data['d'], 'k-', linewidth=1, label='$\delta$')
ax2.plot(maq.t, maq.data['w'], 'k:',linewidth=1, label='$\omega$')
ax1.set_xlabel('T $(s)$')
ax1.set_ylabel('Angulo (deg)')
ax2.set_ylabel('Velocidad (rpm)')

\end{lstlisting}
\end{codeinput}
\begin{codeoutput}




\begin{verbatim}
<matplotlib.text.Text at 0x10a8b0990>
\end{verbatim}



\begin{center}
\includegraphics[max size={0.7\textwidth}{0.9\textheight}]{reporte_files/reporte_18_1.png}
\par
\end{center}

\end{codeoutput}

\end{codecell}

Se nota como el ángulo de la máquina se abre más al estar más carga
mecánicamente. Llega hasta un ángulo de 20, el cual está dentro del
nominal. La velocidad casi no presenta cambio.

\subsubsection{Par eléctrico y
mecánico}\label{par-eluxe9ctrico-y-mecuxe1nico}

\begin{codecell}


\begin{codeinput}
\begin{lstlisting}
plot(maq.t, maq.data['Te'], 'k-', linewidth=1, label='$T_e$')
plot(maq.t, maq.data['Tm'], 'k-.', linewidth=1, label='$T_m$')
xlabel('T $(s)$')
ylabel('Par (pu)')
legend(loc=0)
\end{lstlisting}
\end{codeinput}
\begin{codeoutput}




\begin{verbatim}
<matplotlib.legend.Legend at 0x10a9d5b50>
\end{verbatim}



\begin{center}
\includegraphics[max size={0.7\textwidth}{0.9\textheight}]{reporte_files/reporte_21_1.png}
\par
\end{center}

\end{codeoutput}

\end{codecell}

Esta gráfica es muy similar a la de un sistema de segundo orden ante una
entrada escalon. De hecho es un caso sub amortiguado en el cual el par
eléctrico trata de ``seguir'' inmediatamente al nuevo par mécanico.

\subsubsection{Gráfica ángulo-par}\label{gruxe1fica-uxe1ngulo-par}

\begin{codecell}


\begin{codeinput}
\begin{lstlisting}
plot(maq.data['d'], maq.data['Te'], 'k')
xlabel('$\delta$')
ylabel('$T_e$')

\end{lstlisting}
\end{codeinput}
\begin{codeoutput}




\begin{verbatim}
<matplotlib.text.Text at 0x10aa208d0>
\end{verbatim}



\begin{center}
\includegraphics[max size={0.7\textwidth}{0.9\textheight}]{reporte_files/reporte_24_1.png}
\par
\end{center}

\end{codeoutput}

\end{codecell}

Esta gráfica muestra la convergencia del par mecánico y del ángulo hacia
un punto de equilibrio común. Esta gráfica es interesante en el sentido
que se ve la evolución hacia el estado estable desde un principio.

\subsection{Conclusiones}\label{conclusiones}

Con este trabajo se corrobora que el modelo fue descrito adecuadamente
en un programa de computadora. Así mismo estos resultados son los mismos
que están reportados en el libro de Krauze y las gráficas son idénticas.
Queda pendiente el modelado de la máquina de inducción en el mismo marco
de referencia y posteriormente la inclusión de controles primarios a la
máquina síncrona.



\end{document}

